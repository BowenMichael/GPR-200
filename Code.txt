// GLSL STARTER CODE BY DANIEL S. BUCKSTEIN
float globalIntensity = .1;
vec4 globalColor = vec4(1.0);
const int MAX_LIGHTS = 5;
const bool RUN_WORMHOLE = true; //set to true to run wormhole
#define PI 3.1415926538


//------------------------------------------------------------
// TYPE ALIASES & UTILITY FUNCTIONS

// sScalar: alias for a 1D scalar (non-vector)
#define sScalar float

// sCoord: alias for a 2D coordinate
#define sCoord vec2

// sDCoord: alias for a 2D displacement or measurement
#define sDCoord vec2

// sBasis: alias for a 3D basis vector
#define sBasis vec3

// sPoint: alias for a point/coordinate/location in space
#define sPoint vec4

// sVector: alias for a vector/displacement/change in space
#define sVector vec4


// color3: alias for a 3D vector representing RGB color
// 	(this is non-spatial so neither a point nor vector)
#define color3 vec3

// color4: alias for RGBA color, which is non-spatial
// 	(this is non-spatial so neither a point nor vector)
#define color4 vec4

float squareValue(in float x){
	return x*x;
}

float powerOfTwo (in float base, in int power){
    for(int i = power - 1; i >= 0; --i){
    	base *= base;
    }
	return base;
}

// asPoint: promote a 3D vector into a 4D vector 
//	representing a point in space (w=1)
//    v: input 3D vector to be converted
sPoint asPoint(in sBasis v)
{
    return sPoint(v, 1.0);
}

// asVector: promote a 3D vector into a 4D vector 
//	representing a vector through space (w=0)
//    v: input 3D vector to be converted
sVector asVector(in sBasis v)
{
    return sVector(v, 0.0);
}


// lengthSq: calculate the squared length of a vector type
sScalar lengthSq(sDCoord x)
{
    return dot(x, x);
}
sScalar lengthSq(sBasis x)
{
    return dot(x, x);
}
sScalar lengthSq(sVector x)
{
    return dot(x, x);
}

//Rotation Functions
//mat3(1.0,0.0,0.0,0.0,c,s,0.0,-s,c); //Rotates around the X axis
//mat3(c,0.0,-s,0.0		  ,1.0,0.0,s,0.0,c); //rotates around the y axis
//mat3(c  ,s  ,0.0,-s ,c  ,0.0,0.0,0.0,1.0); //rotates around the z axis
mat3 rotXAxis3D(in float theta){
    float c = cos(theta);
    float s = sin(theta);
    return mat3(1.0,0.0,0.0,0.0,c,s,0.0,-s,c); //Rotates around the X axis
}

mat3 rotYAxis3D(in float theta){
    float c = cos(theta);
    float s = sin(theta);
    return mat3(c,0.0,-s,0.0		  ,1.0,0.0,s,0.0,c); //rotates around the y axis
}


vec4 texture2Dinit(in vec2 px, in vec2 invRes, in sampler2D channel){
    vec2 loc = px * invRes;
    loc *= 1.0;
    return texture(channel, loc);
}

vec4 texture2Dinit(in vec2 uv, in sampler2D channel, in vec2 animator){
    //vec2 loc = px * invRes;
    //loc *= 1.0;
    return texture(channel, uv + animator);
}


//------------------------------------------------------------
// VIEWPORT INFO

// sViewport: info about viewport
//    viewportPoint: location on the viewing plane 
//							x = horizontal position
//							y = vertical position
//							z = plane depth (negative focal length)
//	  pixelCoord:    position of pixel in image
//							x = [0, width)	-> [left, right)
//							y = [0, height)	-> [bottom, top)
//	  resolution:    resolution of viewport
//							x = image width in pixels
//							y = image height in pixels
//    resolutionInv: resolution reciprocal
//							x = reciprocal of image width
//							y = reciprocal of image height
//	  size:       	 in-scene dimensions of viewport
//							x = viewport width in scene units
//							y = viewport height in scene units
//	  ndc: 			 normalized device coordinate
//							x = [-1, +1) -> [left, right)
//							y = [-1, +1) -> [bottom, top)
// 	  uv: 			 screen-space (UV) coordinate
//							x = [0, 1) -> [left, right)
//							y = [0, 1) -> [bottom, top)
//	  aspectRatio:   aspect ratio of viewport
//	  focalLength:   distance to viewing plane
struct sViewport
{
    sPoint viewportPoint;
	sCoord pixelCoord;
	sDCoord resolution;
	sDCoord resolutionInv;
	sDCoord size;
	sCoord ndc;
	sCoord uv;
	sScalar aspectRatio;
	sScalar focalLength;
};

// initViewport: calculate the viewing plane (viewport) coordinate
//    vp: 		      output viewport info structure
//    viewportHeight: input height of viewing plane
//    focalLength:    input distance between viewer and viewing plane
//    fragCoord:      input coordinate of current fragment (in pixels)
//    resolution:     input resolution of screen (in pixels)
void initViewport(out sViewport vp,
                  in sScalar viewportHeight, in sScalar focalLength,
                  in sCoord fragCoord, in sDCoord resolution)
{
    vp.pixelCoord = fragCoord;
    vp.resolution = resolution;
    vp.resolutionInv = 1.0 / vp.resolution;
    vp.aspectRatio = vp.resolution.x * vp.resolutionInv.y;
    vp.focalLength = focalLength;
    vp.uv = vp.pixelCoord  * vp.resolutionInv;
    vp.ndc = vp.uv * 2.0 - 1.0;
    vp.size = sDCoord(vp.aspectRatio, 1.0) * viewportHeight;
    vp.viewportPoint = asPoint(sBasis(vp.ndc * vp.size * .5, -vp.focalLength));
}

struct pLight
{
	vec4 center;
    vec4 color;
    float intensity;
};

void initPointLight(out pLight light, in vec3 center, in vec4 color, in float intensity)
{
  	light.center = asPoint(center);
    light.color = color;
    light.intensity = intensity;
    
}

struct sSphere
{
	float radius;
    vec4 center;
};

void initSphere (out sSphere sphere, in vec3 center, in float radius) 
{
	sphere.center = asPoint(center);
    sphere.radius = radius;

}

//------------------------------------------------------------
// RAY INFO

// sRay: ray data structure
//	  origin: origin point in scene
//    direction: direction vector in scene
struct sRay
{
    sPoint origin;
    sVector direction;
};

// initRayPersp: initialize perspective ray
//    ray: 		   output ray
//    eyePosition: position of viewer in scene
//    viewport:    input viewing plane offset
void initRayPersp(out sRay ray,
             	  in sBasis eyePosition, in sBasis viewport)
{
    // ray origin relative to viewer is the origin
    // w = 1 because it represents a point; can ignore when using
    ray.origin = asPoint(eyePosition);

    // ray direction relative to origin is based on viewing plane coordinate
    // w = 0 because it represents a direction; can ignore when using
    ray.direction = asVector(viewport - eyePosition);
}

// initRayOrtho: initialize orthographic ray
//    ray: 		   output ray
//    eyePosition: position of viewer in scene
//    viewport:    input viewing plane offset
void initRayOrtho(out sRay ray,
             	  in sBasis eyePosition, in sBasis viewport)
{
    // offset eye position to point on plane at the same depth
    initRayPersp(ray, eyePosition + sBasis(viewport.xy, 0.0), viewport);
}

vec2 distort(in vec2 px){
    float modifier = 50.0;
	return vec2(px.x, px.y + cos((px.x + iTime/(modifier/2.0)) * modifier)/modifier);
}

vec3 distort(in vec3 px){
    float modifier = 50.0;
	return vec3(px.x, px.y + cos((px.x + iTime/(modifier/2.0)) * modifier)/modifier, px.z);
}

vec4 texture2DinitDistort(in vec2 px, in vec2 invRes, in sampler2D channel){
    vec2 loc = px * invRes;
    loc *= 1.0;
    loc = distort(loc);
    return texture(channel, loc);
}



bool circleExists(sRay ray, sSphere sphere, inout vec3 dp) {
    dp.xy = ray.direction.xy - sphere.center.xy; //ray from pixel toward the center of the circle
    float lSq = lengthSq(dp.xy), //the length function calulates the square length so it is more efficent just square it
          rSq = squareValue(sphere.radius);
    if(lSq <= rSq){
        return true;
    }
    return false;
}



float calcDiffuseIntensity(in vec3 surfacePos, in vec3 surfaceNorm, in pLight light, inout vec3 normalizedLightVector){
        //Diffuse Intensity
        vec3 lightVector = light.center.xyz - surfacePos;
        float lightVectorLengthSq = lengthSq(lightVector); //saves a square root function
        normalizedLightVector = lightVector * inversesqrt(lightVectorLengthSq); //declaration of var
        float diffusionCoefficent = max(0.0, (dot(surfaceNorm, normalizedLightVector)));
        float attenuation = (1.0 - lightVectorLengthSq/squareValue(light.intensity));
        return diffusionCoefficent * attenuation; 
}

float calcSpecularIntensity(in vec3 surfacePos, in vec3 surfaceNorm, in sRay ray, in vec3 normalizedLightVector ){
		//Blinn-Phong Reflectance
        vec3 viewVector = ray.origin.xyz - surfacePos; //Created because viewVector is used twice
        vec3 normalViewVector = viewVector * inversesqrt(lengthSq(viewVector)); //Multiplied by the inverse and uses the dquared length function
        vec3 halfWayVector = normalizedLightVector + normalViewVector; //Used twice 
        vec3 normalHalfWayVector = halfWayVector * inversesqrt(lengthSq(halfWayVector));
        float specCoefficent = max(0.0, dot(surfaceNorm, normalHalfWayVector)); //Multiplied by the inverse and uses the dquared length function
        return powerOfTwo(specCoefficent,50); //improved eff by removing pow function and adding a power of two function
}

//------------------------------------------------------------
// RENDERING FUNCTIONS

// calcColor: calculate the color of current pixel
//	  vp:  input viewport info
//	  ray: input ray info
color4 calcColor(in sViewport vp, in sRay ray)
{
    //texture init
    vec4 t1 = texture2DinitDistort(vp.pixelCoord, vp.resolutionInv, iChannel0);

      
    //CubeMap (Code could be contensed for a easier viewing experiance)
    vec3 rayVec = ray.direction.xyz;
   
    //rotation based on mouse position
	vec2 theta = (iMouse.xy* vp.resolutionInv)*4.0; //Makes the mouse position more proportinal to the output screen 
    theta.y += PI * .25;//allows for a better viewing experiance of the scene
    theta *= 2.0; //allows for a better viewing experiance of the scene
    rayVec *= rotXAxis3D(-theta.y) * rotYAxis3D(theta.x); //rotates the scene to an angle based on the mouse position
    //distort(rayVec);//Distort for fun
    
	vec4 cube = texture(iChannel2, rayVec);  //Render Cube color
    
    //sphere init
    sSphere sphere;
    //initSphere(sphere, vec3(sin(iTime), 0.0, -4.0), .5);
    initSphere(sphere, vec3(0.0, 0.0, -4.0), .25);
    
    //Lights init
    pLight lights[MAX_LIGHTS];
    vec2 mousePointInspace = (iMouse.xy * vp.resolutionInv)  * 2.0 - 1.0; //turns mouse XY into a NDC scale
    
    //other light implementation that don't quite work together very well. I recomend leaving them commented
    //initPointLight(lights[0], vec3(vp.resolution.x*.5, vp.resolution.y*.5, 0.0), vec4(1.0), 10.0);
    //initPointLight(lights[2], vec3(cos(iTime), sin(iTime), 0.0), vec4(1.0), 100.0);
    //initPointLight(lights[3], vec3(2.0,  2.0, 0.0), vec4(1.0), 10.0);
    
    //surface init
    vec3 position = vec3(vp.pixelCoord, -1.0); //surface position
    vec3 normal = vec3(0.0, 0.0, 1.0); //surface 
    //vec3 surfaceNorm = normalize(vec3(vp.viewportPoint.xy, 1.0)); //other way to normalize
    vec4 t2;
    if(RUN_WORMHOLE){ // run Wormhole
         initPointLight(lights[1], vec3(mousePointInspace.x,  mousePointInspace.y, 0.0), vec4(1.0), 1.0); //lighting with mouse when circle exists
        if(circleExists(ray, sphere, position)){
            //Unneccacary code
            //position.z = squareValue(sphere.radius) - ((position.x*position.x)+(position.y*position.y));
            //position.xy = sphere.center.xy + vec2(position.x, position.y);
            //normal.xy = (position.xy - sphere.center.xy) / sphere.radius;
            //light color init
            //vec4 diffuseColor = vec4(normal * 0.5 + 0.5, 1.0);;
            //vec4 specularColor = vec4(1.0);
            //vec4 t2 = texture2Dinit(vp.pixelCoord, vp.resolutionInv, iChannel1, vec2(iTime*.5));

            return vec4(0.0);
        }
        else{ //in else for efficency
            //assisted by Zylann: https://godotengine.org/qa/13023/shaders-how-does-one-create-blackhole-effect-using-shaders
            
            //Render black hole effect
            float p = sphere.radius * .1; // size of the black hole
            vec2 diff = sphere.center.xy - vp.viewportPoint.xy; //Where the black hole is in realation to space
            float distSq = lengthSq(diff); //distance squared rather than using length
            vec2 normDiff = diff * inversesqrt(distSq); //inverse sqrt to get the normal
            vec2 uv = vp.uv + normDiff * (p / (distSq + 0.01)); // Modifiter on the UV to create the effect. similar to the Gravitational attraction formula (G*m1*m2)/r^2 = Force. M1 is the black hole. M2 is the pixel. r^2 is distSq 
            t2 = texture2Dinit(uv, iChannel1, vec2(iTime*.5)); //defines the texture   
            return t2;// + sumOfColors; 
        }
    }
    else{
        //inits a light when not running wormhole so that the renders for parts 2-4 work as intended
    	initPointLight(lights[1], vec3(iMouse.x,  iMouse.y, 0.0), vec4(1.0), 15.0); //lighting with mouse when circle exists
    }

    //Lighting
    
    //light color init
    vec4 diffuseColor = vec4(normal * 0.5 + 0.5, 1.0);;
    vec4 specularColor = vec4(1.0);
    
    vec4 backroundColor;
    for(int i = MAX_LIGHTS-1; i >= 0; --i)
    {
		vec3 normalizedLightVector;
        backroundColor += (calcDiffuseIntensity(position, normal, lights[i], normalizedLightVector) * diffuseColor 
                       + calcSpecularIntensity(position, normal, ray, normalizedLightVector) * specularColor) * lights[i].color;
    }
    //Final Color calculation
    vec4 sumOfColors = globalIntensity * globalColor + backroundColor;
    
    //Blackhole with lighting
    //return t2 + sumOfColors; 
    
    //rendering for part 2
    return t1;
    
    //rendering for part 3
    return t1 + sumOfColors;
    
    //Rendering for part 4
    return cube + sumOfColors;
    

    
    // test inputs
    //vec4 t2 = texture(iChannel1, vp.uv );
    //return vec4(mix(t1.rgb,t2.rgb, .5), 1.0);
    //return vec4(.5);
    //return color4(ray.direction.xyz == vp.viewportPoint.xyz); // pass
    return color4(lengthSq(vp.viewportPoint.xy) >= 0.25); // pass
    //return color4(vp.uv, 0.0, 0.0);
    //return color4(vp.ndc, 0.0, 0.0);
    //return vp.viewportPoint;
}


//------------------------------------------------------------
// SHADERTOY MAIN

// mainImage: process the current pixel (exactly one call per pixel)
//    fragColor: output final color for current pixel
//    fragCoord: input location of current pixel in image (in pixels)
void mainImage(out color4 fragColor, in sCoord fragCoord)
{
    // viewing plane (viewport) inputs
    const sBasis eyePosition = sBasis(0.0);
    const sScalar viewportHeight = 2.0, focalLength = 1.5;
    
    // viewport info
    sViewport vp;

    // ray
    sRay ray;
    
    // render
    initViewport(vp, viewportHeight, focalLength, fragCoord, iResolution.xy);
    initRayPersp(ray, eyePosition, vp.viewportPoint.xyz);
    fragColor += calcColor(vp, ray);
}
